garbage value (çöp değer) : 

!!eğer otomatik ömürlü bir değişkene ilk değer vermez isek (onu initialize etmezsek) o değişken çöp değişkne ile başlar
!!bir değişjkeni çöp değeri ile kullnamak tanımsız davranıştır


------------------------------------------


!! bir blok içinde bildirilen isimlerin scope'u bildirildiği noktadan ilgili bloğun kapanan küme parantezine kadar olan kod alanıdır

int main(){
if(1){
int x = 10;
}
x = 20; // burada hata olur parantez dışında kullanılmıştır.

------------------------------------------

fonskiyonlar (functions):

a) fonksiyonu tanımlamak (to define a function) (function defibition)
b) fonksiyonu çağırmak (to call a function) (function call)
c) fonksiyonu bildirmek (to declare a function) (function declaration)

--------------------------------------------

while(expr){
; // hiçbir şey yapılmaması istendiği zaman  ';' koyulur
}

---------------------------------------

return;
sadece void function'da kullanılır
kodun belli bölümleri kullanılmak istendiği zaman kullanılmalı

void func(int x){
//statemnet
//statemnet
if ( x > 10){  //x >10 doluğu zaman diğer statement çalışmasın fonksiyonu sonlandır
return;
}
//statement;
}

-----------------------------------------

!! fonskiyon 0 dışında hangi değeri döndürürse döndürsün true değerini döndürür

3. başarı bilgisi

standart c kütüphanesi 0 = başarılı diğer değerler başarısız olarak döndürür



--------------------------------------------

while (expr) : expr true olduğu sürece devam eder

-while parantezi içinde void tür olamaz 
-parantex içi boş olamaz
-parantex içinde statement olamaz


--------------------------------------------

!!işaretli türlerde taşma tanımısz davranıştır

-------------------------------------------

while (expr){
while( (expr2){
if (c_exp)
goto out
}
}
out:

//bütün döngülerden çıkılmak istenirse goto statemnet kullan

-------------------------------------------

continue; 
-sadece döngülerde kullanılır
-döngüden çıkarmaz
-kendinden sonrakileri yapma

while (exp)
{
statement
statement
statement
continue; //continue altında kalan statement'lar kullanılmaz döngünğn başına döner
statement
statement
}

----------------------------------------

long double --> double --> float //bu kısım var ise burası ile yapılır

long long --> long --> int

short --> char --> _Bool


!! integral promotion : int türünden düşük operandları (short, char, _Boll) int türüne yükseltmeye denir

- eğer rank'ler farklı ise fakat büyük olan rank işaretsiz ama küçük olan işaretli ise rank'i büyük unsigned ile yapılır

- eğer rank'ler aynı ise işaretler farklı ise rank'i küçük olan unsigned yapılır

dikkat edilmesi gerekenler :
- işaretli ile işaretsizi işleme sokma
- int altı türlerin int türüne yükseltileceğini unutma
- rankler aynı ise tür dönüşümü olmaz

!! işaretsiz türlerde taşma diye bir şey yoktur

!! c dilinde lojik ifade beklenen yerlerde void kullanılamaz
 
--------------------------------------


(void)isprime(x) //bir fonksiyonun geri dönüş değerini kullanmak istemediğimiz zaman bunu yaparız

---------------------------------------

int main(void)
{
for (int i = 0; i < 100; i++){
printf("%d ", rand()); //2. çalıştırlmasında aynı tohum değerinde dolayı aynı sayılar rastgele üretilir
}
}

-----

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define randomize() (srand((unsigned)time(0))) 

int main(void)
{
randomize();

for (int i = 0; i < 10; i++)
{
	printf("%d\n",rand()); //her çalıştığında farklı sayı üretir
}

}


--------------------------------------

big O notation : algoritmanın karmaşıklığını anlatmak için söylenir
Big O(1) : constant(sabit) time
Big O(n) : linear complexity
Big O(n log n) : linearitmic 
Big O(n2) : quadretic complexity
Big O(n3) : cubic complexity


-----------------------------------------

int main(void)
{
int a[10];
int b[10];
a = b; //böyle yazılamaz, array decay kuralı ile igilidir
}

array decay : bir dizinin ismin bir ifade (expression) içinde kullandığızda derleyici
dizi ismini dizinn ilk elemanının adresine dönüştürme işlemine denir

------------------------------------------

!! fonksiyonların parametre değişkenleri dizi türlerinden olamaz
void func (int a[10])

!! fonksiyonların geri dönüş değeri türü dizi türü olamaz

!! arraylerde eğer ilk değer verilmez ise static ömürlü ise zero ile hayata başlar

--------------------------------------------

int main(void)
{
int a[10] = {2, 5, 7, 23, 90, 6, 4, 13, 22, 80}; //ilk değer verme
int a[10] = {2, 5, 7}; //geri kalan değerler 0 ile hayata başlar
int a[10] = {0}; //0 değerleri hepsine atanır
int a[] = {0,1,2,3,4}; //dizinin boyutunu ilk değer verince kendisi anlar
}


------------------------------------------

global tanımlı değişkenler 0 değeri ile başlar (int a;)

otomatik tanımlı değişkenler ub olur

-----------------------------------------

C dilinde (tipik olarak) bir yazı elemanlarının türü 'char' olan bir dizide tutulur

!! yazının uzunluğu dizideki null karekterinin bulunması ile bulunur
 

char str[5] = {'b', 'u', 'g', 'r', 'a'}; //burada tanımsız davranış var
char str[5] = "bugra; //tanımısz davranış var, sonunda '\0' vardır yani 6 karakterleri

------------

int main(void)
{
char str[40] = "muharrem; //tanımısz davranış yok
for (int i = 0; i < str[i] != '\0'; ++i){
printf("%c", str[i]);
}
}

------------

puts(str); //bu fonksiyon bugrahan serttas yazısını ekrana yazdırır
gets(str); //bu fonksiyonu ekrandan yazıyı alır

int ch;
ch = getchar(); // char karakteri alır

-----------

!! adres operatörünün operandı L value expression olmak zorunda

----------

int main(void)
{
int a[5] = {1,2,3,4,5};
int b[20] = {0};

int * p = &a[0];
int* p = a; //aynı anlama gelir(array decay)
p = a;
}

!! asla pointer değişkene adres olmayan atama yapma

--------------


int main(void)
{
int x = 346;
double * p;
p = &x;
!! asla bu şekildede kod yazma, tür dönüştürme kullan
}

---------------

int * ptr = &x;

ptr //ptr'nin değeri hangi adres
&ptr //ptr bellekte nerede

--------------

int main(void)
{
int x = 4547;
*&x = 987; //x = 987 aynı anlamda
}

int main(void)
{
int a[4] = {20 ,56 , 90 ,12};
*a = 777; //dizinin ilk elemanının değeri 777 olur

}

int main(void)
{
int x = 5;
int y = 10;
int z = 40;
int* ptr = &x; 
    *ptr = 65; // x = 65
ptr = &y;
    *ptr = 90; // y = 90;
ptr = &z;
    *ptr = 777; //z = 777;
}


--------------------

!! c dilinde diziler bir fonksiyondan bir fonksiyona sadece call by referance olarak gönderilebilinir, call by value çalışmaz

------------------


const int x = 10;

int const x = 10 

//ikisi arasında fark yoktur

--------------------

!! &a[i] = a // aynı anlama gelir
 
!! &a[i] = a + i //aynı anlama gelir -

!! a[i] = *(a + i) //aynı anlama gelir 

!! *p = p[0]; //aynı anlama gelir

!! int p[] = int *ptr

--------------------

- L value olduğunu tespit etmek için başına '&' koyulduğu zaman hata vermiyor ise L value'dur

l value ifadeler :

a
(expr)
*ptr
a[b]
ptr->x
x.y

!! geri kalanlar r value

------------------------------------------


!! adres döndüren bir fonksiyon otomatik ömürlü bir yerel değişkenin adresini döndürmemeli.

int * get_value(void)
{
int x; //static olmalıydı burası, char'da olsa olmaz
printf("bir tam sayi girin: ");
scanf("%d", &x);

return &x; //otomaitk ömürlü değişken geri dönüş değeri olarak kullanılamaz, DANGLİNG POİNTER
}


----------

// 3 pointerda 90 değerini gösterir çünkü x değeri tekrar hayat gelmez

int* get_value(void)
{
static int x;
printf("bir tam sayi girin: ");
scanf("%d", &x);

return &x;
}

int main()
{
int* p1 = get_value();
int* p2 = get_value();
int* p3 = get_value();

printf("%d\n", *p1);
printf("%d\n", *p2);
printf("%d\n", *p3);

}

----------

int * foo(int * p)
{
++* p;
return p;
}
//main içinde tanımalndığı için, x1tanımsız davranış yoktur
int main(void)
{
int x = 99;
int * ptr = foo(&x);
printf("*ptr = %d\n", *ptr); //cevap = 100
}

-----------

int* foo(void)
{
int x = 10;
int* p = &x;

return p; //hatalı x'in adresini döndürür ancak x otomatik ömürlü
}

-----------

int* foo(int *ptr)
{
int* p = ptr;

return p; //bu şekilde hata olmaz, ptr döndürür çünkü
}

------------

adres döndüren bir fonksiyon :

a) statik bir ömürlü nesnenin adresini döndürebilir
  -global bir değişkenin adresi
  -static yerel bir değişkenin adresi
  -string literalleri

b) dinamik ömürlü bir nesne adresi 

c) fonksiyon çağıran koddan aldığı adresi çağıran koda geri döndürebilir

-------------

!! const nesne  adresi türünden örneğin T bir tür olmak üzere
const T * türünden const olmayan nesne türüne yani örneğin T* türüne 

a) c++ dilinde örtülü dönüşüm yoktur
b) c dilinde böyle bir dönüşüm örtülü olarak yapılır ancak bir önlem alınmaz ise kodun okuyucusu bu dönüşüm yanlışıkla yapıldığını dönüşür
C derleyicilerinde böyle bir örtülü dönüşüm yapılması durumunu şüpheyle karşılayarak uyarı mesajı verirler

C dilinde böyle dönüşümleri bilerek istiyerek yapıyor isek mutlaka ve mutlaka tür dönüştürme operatörünü (type - cast) kullanmalıyız

---------------

int main()
{
char str[] = "bilgin";

str[0] = 'y';  // burada ub yok burası çok önemli
}


int main(void)
{
const char* p = "murat";

*p = 'S'; //c'de sentax hatası değil ancak ub olur o yüzden const kullan, C++ 'da hata olur

}


-----------------

int main(void)
{
char * p = "murat";
printf("[1] %zu\n", sizeof(p)); //4 cevabı çıkar, derleyiceye bağlı
printf("[2] %zu\n", sizeof(*p)); //1
printf("[3] %zu\n", sizeof("murat")); //6 (murat\0)
printf("[3] %zu\n", sizeof(p++)); //4, sizeof işlem üretmez
printf("[3] %zu\n", strlen(p)); //5 
}

------------------

char str[100] = "seyfullah";
printf("%zu %zu\n", sizeof(str), strlen(str)); //100 9
printf("%zu %zu\n", sizeof str, strlen(str)); //100 9(aynı anlama gelir)
printf("%zu %zu\n", sizeof "mert", strlen("mert")); //5(dizinin boyutu) 4(yazının uzunluğu)

------------------

int main(void)
{
char str[100] = "murat";
str = '\0'; //boş yazı yapar
str[0] = '\0'; //boş yazı yapar
}

---------------

- *p[1] pointer dizisinin 1 indisli elemanının gösterdiği nesne
- p[1][2] pointer dizisinin 1 indisli elemanının gösterdiği dizinin 2 indisli elemanı

-------------

pointer söz konusu olmadığı sürece const önce veya sonra gelmesi arasında fark yoktur

int main()
{
const int a[5] = {12, 54,23,254,76};
int const a[5] = {12, 54,23,254,76};
}


-----------

int a = 1, b = 2, c = 4;

int main(void)
{
int * const p[3] = {&a, &b, &c}; //bu şekilde olunca dizinin elemanlarının değiştimek hata
p[2] = &ival; //syntax hatası
*p[2] = 456; //adrese atamama yapmak hata değil
}

-----------

int a = 1, b = 2, c = 4;

int main(void)
{
const int * const p[3] = {&a, &b, &c}; 
p[2] = &ival; //değer değiştirmek hata
*p[2] = 333; //adrese atamama yapmak hata}



--------------

!! const char * p[] = {} //look up table için bolca kulllanıcağız, dizinin elemanlaı değişebilir

!! const char * const p[] = {} //p'nin elemanlarına bir atama yapılamaz, p'nin gösterdiği nesneyi değiştiremeyiz

!! char * const p[] = {} //p'nin gösterdiği nesneyi değiştiremeyiz

---------------

// aşağıdaki şekilde implemente etmek gerekir

eğer statik yapmaz isek dizi tekrar oluştuğundan tekrar tekrar oluşturulacak o yüzden static yapmak gerekir

void func(void)
{
  static const char * const pdays[] = {
  "", //indeks ile sayma sayısının aynı olması için yapılır
  "pt",
  "sali",
  "carsamva", 
  "persembe",
  "cuma",
  "cumartesi",
  "pazar",
};
}

--------------------------------

pointer to pointer
------------------

int main(void)
{
int x = 10;
int * ptr = &x;
int ** p = &ptr; 
//*p  = ptr'ye erişilir, **p = *(*p) = x
//**p p'nin gösterdiği nesnenin gösterdiği nesnedir
}

----------------

int main(void)
{
int a[] = {10, 20, 30, 40, 50};
int * p = a;
int** ptr = &p;

++*p; //a dizisinin ilk elemanı 10, 1 artar
++* ptr; // ++p //dizinin 2. elemanın adresini gösterir

}

----------------

int main(void)
{
int x = 10;
int y = 45;
int * p1 = &x;
int * p2 = &y;

printf("%d %d\n", *p1, *p2); //10 45 çıkar

pswap(&p1, &p2);

printf("%d %d\n", *p1, *p2);
}

void pswap(int ** ptr1, int ** ptr2)
{
int *ptemp = *p1;
*ptr1 = *ptr2;
*ptr1 = ptemp;
}


----------------------------------

// pointer to pointer için güzel bir örnek

int * get_array_min_max(const int * pa, size_t size, int ** pmin, int **pmax);
{
*pmin = *pmax =(int*)pa;
for (size_t i = 1; i < size; ++i){
if (pa[i] > **pmax){
*pmax = (int *)&pa[i]; //(int*)pa +i (bu şekilde de olur)
}else if (pa[i] < **pmin){
*pmin = (int *)&pa[i];
}
}
}

int main(void)
{
int a[SIZE];

randomize();
set_array_random(a, SIZE);
print_array(a, SIZE);
int * ptr_min;
int * ptr_max;

get_array_min_max(a, SIZE, &ptr_min, &ptr_max); //değişken *ptr_min ile tanımlandığı için, int** pmin ile çağrılır

printf("min = %d ve min index = \n", *ptr_min, ptr_min - a);
printf("max = %d ve max index = \n", *ptr_max, ptr_max - a);

swap(ptr_min, ptr_max); //swap hazır fonk. dizinin en büyük elemanı ile en küçük elemanının swap edilmesi
print_array(a, SIZE);
}


---------------------

pointer to pointer için güzel örnek

void printf_names(char ** ptr, size_t size)
{
for (size_t i = 0; i < size; ++i){
printf("%s ", ptr[i]);
}
printf("\n\n");

}

int main(void)
{
const char* p[] = {"ali", "veli", "mehmet", "can", "deniz"}

print_names(p, asize(p));

}

---------------------


!! const ne'den önce gelirse const olan o dur

!! int * const p = &x; //p'ye atama yapılmaz

!! int const *  p = &x; //*p'ye atama yapılmaz

----------------------

void func(int * p); //aynı anlamdadır
void func(int p[]); //aynı anlamdadır

void func(int p[10]) //aynı anlamda derleyici içini boş görür
void func(int p[]) // aynı anlamda derleyici içini boş görür

void func(int ** p); //aynı anlamdadır
void func(int * p[]); //aynı anlamdadır


======================================================================

void pointer
------------

int main(void)
{
int x = 12;
void * vp = &x;

int * iptr = vp; //void* ===> int *, c'de hata olmaz c++ hata olur
int * iptr = (int *)vp; //c++'da böyle legal olur c'dede böyle yazabilirsin
}

!! voişd * : türsüz pointer diyebiliriz, generic kodlar yazmak istediğimizde kullanabiliriz, dönüştürmek gerekir ama


------------

aşağıdaki durumlar legaldir

!!aynı tam sayı türünün işaretlisi veya işaretsizi tanımsız davranış olmaz


int main()
{
unsigned int x = 10u;
int* ptr = (int*)&x;
}


char* türlerine olan dönüşüm, herhangi bir nesne char'lardan oluşan b,r tür gibi kullanılabilir

int main()
{
double dval = 12873425;
char* p = (char*)&dval;
}

---------------

//türden bağımısız generic bir koddur, 


!! aşağıdaki şekilde void kullanmka ve char'a dönüştürme generic bir kod yazmamızı sağlar


void gswap(void * vp1, void* vp2, size_t sz)
{
char * p1 = (char *)vp1;
char * p2 = (char *)vp2;

while (sz--){
char temp = *p1;
*p1++ = *p2;
*p2++ = temp;
}
}

int main(void){
int x = 10, y = 45;
double d1 = 4.587123;
double d2 = 2.981555;

int a[5] = {1, 2, 3, 4, 5};
int b[5] = {-1, -2, -3, -4, -5};

printf("x = %d  y = %d\n", x, y);
printf("d1 = %f  d2 = %f\n", d1, d2);
print_array(a, 5);
print_array(b, 5);


gswap(&x, &y, sizeof(int));
gswap(&d1, &d2, sizeof(double));
gswap(a, b, sizeof(a));

printf("x = %d  y = %d\n",x, y);
printf("d1 = %f  d2 = %f\n",d1, d2);
printf_array(a, 5);
print_array(b, 5);
}

=================================

function pointers
-----------------

int main(void)
{
void * vp; //adres olsunda ne olursa olsun, o adresteki nesneni türünü bilmesine gerek yok
&vp ==> void** //generic değildir, void * türünden bir nesnenin adresidir
}

----------

void func(void ** p) //bu şekilde olması gerekir, void **
{
*p = & //*p ptr demektiri, herhangi bir atama yapabilriz çünkü generictir
}

int main(void)
{
void* ptr;
func(&ptr);
}


---------


int main(void)
{
int * ip;
void * vp;
void ** vpp;

ip = &ip; //error, çünkü int * türünü int **'a atadık
vp = ip //legal, void * 'a bütün adresler atanabilinir
vp = &ip //legal, void pointer atanabşlmesi için tek şart onun adres olması
vpp = &ip //error, void** ,int ** 'a atanamaz
vpp = &vp // legal, void** , void**
vpp = &vpp //error, voidd**, void***
vp = &vp // legal, void * için tek koşul adres olması

!! kendi adresini tutabilecek tek pointer void pointer, void * vp = &vp;
}

======================================================

function pointers :
------------------

bir fonksiyonun adresi olan tür fonksiyonun parametrik yapısı ve geri dönüş değerinden elde edilen bir tür

int foo(int);

!! foo fonksiyonunun türü  int(int)

!! char* strchr(const char*, int c) ---> char*(const char *, int)


fonksiyon türü           fonksiyonun adresi türü
--------------           -----------------------
int (int)                int (*)(int)
double (double, double)  double (*)(double, double)


!! int (*fp)(int); //sadece parametresi int olanı tutar

------------

//strlen adresini bir değişkende tutulması
size_t strlen(const char *);

int main(void)
{
size_t(*fp)(const char *) = &strlen;
size_t(*fp)(const char*) = strlen; //aynı anlama gelir

}

----------------


//sum adresini bir değişkende tutulması ve atama yaoılması
int sum(int,int int);

int main(void)
{
int (*fptr)(int, int, int) = &sum;
fptr = &bar; 
fptr = bar (aynı anlama gelir);
}

-------------------

int foo(int x)
{
printf("int foo(int) called!!!\n");
return x * x;
}

int main(void)
{
int (*fp)(int) = foo;
fp(12); //bu şekildede çağırabiliriz. başka bir isimle
}

-------------------

void func(void)
{
printf("func called!");
}

int main(void)
{
void (*fp)(void) = &func;
fp();
(*fp)() //bu şekilde de çağırılanabilinir, !!function pointer vurgusu için yapılır
}

-----------------------
void func(int (*x)(int))
{
x();
}

int f1(int);
int f2(int);
int f3(int);

int main(void)
{
func(f1); //&f1 bu şekildede olur
func(f2);
func(f3);
}

--------------------------

!! ikisi arasında fark vardır

func(foo()) //foo'nun geri dönüş değeri ile func çağrılır

func(foo) //func'a foo'yu çağırmak


-------------------

typedef int (*FUNC)(int);

int bar(int x)
{
    return x * x + 1;
}

FUNC foo()
{
    return &bar;
}

int main()
{
    printf("%d\n", foo()(11));
}

---------------------

!! fonksiyon geri dönüş değeri fonksiyon olabilir

typedef int (*FUNC)(int);

int bar(int x)
{
    return x * x + 1;
}

FUNC foo()
{
    return &bar;
}

int main()
{
    printf("%d\n", foo()(11));

/*
// bu şekide de olabilirdi
FUNC fptr = foo()
int x = fptr(20);

printf("x = %d\n", x);
*/
}

====================================

function pointer arrays :

haftanın ayrı günlerinde farklı görevler var ise bunu şu şekilde yaparız (jump table) :
- anahtarı indekse dönüştür indekste bir fonksiyon adresi elde et. o adresteki fonksiyonu çağır.

haftanın farklı günlerinde yapılacak işleri farklı fonksiyolar olarak tanımlarız. bir pointer dizisinde bunların adreslerini tutarız
ve bu fonksiyona bir index gönderip o indeksi dizi elemanı olan fonksiyon pointerının gösterdiği fonksiyonu çağırırız

------

2 boyutlu dizi olunca elemanın adresi : ar  + 1 / &ar[0] / a
tek boyutlı dizi olunca elemanın adresi : a / &ar[0]


-------

int f1(int);
int f2(int);
int f3(int);
int f4(int);
int f5(int);

int main(void)
{
int (*fptr)(int)) = &f1;

int (*fa[5])(int); //bu şekilde gösterilir
int (*fa[5])(int) = {f1, f2, f3,f4,f5}; //diziye bu şekilde ilk değer verilebilir
int (*fa[])(int) = {&f1, &f2, &f3,&f4,&f5} //anlam farklılığı olmaz
asize(fa) // 5

int (*fp)(int);
int (**fptr)(int) = &fp; //dizinin ilk elemanın adresi, fp'nin adresini fonksiyon pointerda tutulması
*fptr = fp //fptr diref edersel fp'yi elde ederiz

int (*fa[](int) = {f1, f2, f3, f4, f5}; //geri gönüş değeri, fonksiyon ismi, fonksiyon değerlerinin türü
int (**fptr)(int) = fa; //dizinin ilk elemanının adresi
int (**fptr)(int) = &fa[0] //aynı anlama gelir

}


---------------------------

// bunun yerine typedef kullanabiliriz

typedef int (*FPTR)(int); //kolay yol

int main(void)
{
FPTR fa[] = {f1,f2,f3,f4,f5};
FPTR * p = fa;
}

---------------------

typedef void (*FUNCPTR)(int); //geri dönüş değeri olmayan int değişken alan parametre

int main(void)
{
FUNCPTR fa[] = {&f1,&f2,&f3,&f4,&f5};
for (size_t i = 0; i < asize(fa); ++i){
fa[i](i); //sırayla fonksiyonları yazdırır, 2. parametre fonksiyon parametresi
}
}


=================================================================

multi-dimesional arrays (çok boyutlu diziler) :

int main()
{
int a[10][20];

int* p = a; //hata pointer türü ile dizi boyutları türü aynı olmalıdır, bu şekilde yapıınca a + 1 diiznin 4 byte sonraki elemanı gösterirr

int(*tr)[4] = a; //bu şekilde olur
}


------------

int main(void)
{
int a[10][20];
//matrisin 200 tane tam sayısından her biri
a dizisinin elemanlarının elemanları 
}

-----------

tür uyuşmazlığı kontorlü

int main(void)
{
int a[10][20];
int *p = a //error
int * p1 = &a[0][0] //legal
int * p2 = a[0]; //legal, array decay a[10] a ile gösterilebilinir

//p a dizisinin ilk elemanının ilk elemanını göstermesinin yolları
int * p;
p = &a[0][0];
p = a[0]; //array decay
p = (int *)a;
}

----------------------

int main()
{
double ar[10][32];

double(*p)[32] = a;

for (int i = 0; i < 10; ++i) {
printf("%p %p %p\n",  &a[0] ,a + 1,  p++); //aynı adresler yaz
}
}

--------------- -------------------------

int main(void)
{
int a[4][3] = {
{1,1,1},
{2,1,12},
{5,6,4},
{0,4,3},
}

int(*p)[3] = a;

for (int i = 0; i < 4; ++i){

print_array(a[i],3); // dizinin elemanlarını yazar
print_array(&a[i][0],3); // dizinin elemanlarını yazar
print_array(*p, 3); //dizinin elemanlarını yazdırır
print_array(*p++, 3); //dizinin elemanlarını yazdırır
print_array(*p++, 3); //dizinin elemanlarını yazdırır
print_array(&(*p)[0], 3); ++p; //dizinin elemanlarını yazdırır

}
}

--------------

int main(void)
{
int a[][] = {1,5,7,2,3,6,1,4,7,8,3,5,2}; //error, 2. parantez dolu olmalı
int a[][4] = {1,5,7,2,3,6,1,4,7,8,3,5,2}; //legal
int a[4][] = {1,5,7,2,3,6,1,4,7,8,3,5,2}; //error 2. paratez dolu olmalı

}

--------------

int main(void)
{
int* a[5][10];
int* b[10];
}

------------

int a[10];
int (*foo())[10]
{
return &a; //int (*)[10]
}

int main(void)
{

}

----------

//tür eş ismi ile yazma

int a[10];
typedef int inta10[10];
inta10 * foo()
{
return &a; //int (*)[10]
}

-----------


int main(void)
{
int a[10] = { 0 };

int* p = a; //bu şekilde ilk adrese erişiriz

//&a ile ilk değer vermek istiyorsak aşağıdaki şekilde olur
int * ptr = &a;; //bu şekilde olmaz
int (*ptr)[10] = &a;
}

-------------

int main(void)
{

int a[10];
int * p = a; 
*p //a dizinin ilk elemanına erişir

int (*ptr)[10] = &a
*ptr //a dizisinin kendisine erişilir

int * p = *ptr;
*p //dizinin ilk elemanın adresine dönüşür 
}
 
--------------

---------- 

//eğer dizi tek elemanlı olsaydı  aşağıdaki şekilde olurdu

int main(void)
{
int a[4]

set_ar(a, 4); //bu şekilde de olur
set_ar(&a[0], 4); //bu şekilde de
}

!! çok boyutlu dizi fonksiyona nasıl geçirilir :

----------------

int main()
{
int a[4][5];

int(*p1)[5] = a; //*p ile elemana erişilir
int(*p2)[5] = a;

set_ar(a, 4);
set_ar(&a[0], 4)
}


----------------

void set_ar(int(*p)[5], int size)  //bu şekildede yazılabilir
{
for (int i = 0; i < size; ++i){
for(int k = 0; k < size; ++k){
p[i][k] = rand() % 10;
}
}

---

void set_ar(int(*p)[5], int size) //bu şekildede yazılabilir
{
while(size--){
for (int i = 0; i < 5; ++i)
(*p)[i] = rand() % 10;
++p;
}
}

---

void set_ar(int(*p)[5], int size) //bu şekildede yazılabilir
{
for (int i = 0; i < size; ++i){
set_array_random(p[i], 5);
}
}

------

void print_names(const char(*p)[20], size_t size)
{
for (size_t i = 0; i < asize(names); ++i){
printf("%s ",p[i]);
}

int main(void)
{
char names[][20] = {
"bugra", "begum", "ali","veli","deniz","efe","oya",
"oya", "begum", "merve","veli","deniz","mahmut","oya",
"bugra", "mert", "ali","veli","ece","mustafa","oya",
"buse", "begum", "rıza","dila","deniz","suat","oya",
}

printf_names(names, asize(names));
}

---------

!! aşağıdakiler aynı anlamdadır

void foo(int * p);
void foo(int p[]);

void bar(int ** p);
void bar(int * p[]);

void baz(int (*p)[10]);
void baz(int p[][10]);

void func(int (*p)(int));
void func(int (int));

==================================================

bellek üsütnde (in-memmory) yapılan formatlı okuma yazma işlemleri:
------------------------------------------------------
<stdio.h>

printf : stnadart outputa yapmak için 
sprintf : adresteki bir diziye yazdırmak için (belleğe)
fprintf : dosyaya yazdırmak için

----------

int main()
{
int ival = 278345;
double dval = 34.742873;
char str[SIZE];

printf("[%d] [%f]", ival ,dval); //ival ve dval'i ekrana yazar
sprintf(str, "[%d] [%f]", ival, dval); // ival ve dval' diziye yazar
puts(str); //diziyi ekrana basar
}


--------------

snprintf : sprintf'den farklı olarak taşmayı kontrol eder
int snprintf(char * pstr, size_t n)

int main(void)
{
char str[10];
int x;

printf("sayi girin: ");
scanf("%d",&x);

snprintf(str, 10,"hasan_%d", x);
printf("[%s]\n", str);
}


----------------------------------------

int scanf(const char * pfm,...);
int sscanf(const char * pbuf, const char *pfm, ...);
int fscanf(FILE * pbuf, const char * pfm,..);

sscanf : bir dizide tutulan yazıya işlem yapar

int main(void)
{
int x,y,z;
char buffer[SIZE] = "7656 565 567656";

printf("3 sayi giriniz: ");
sscanf(buffer, "%d%d%d",&x, &y, &z);

printf("x = %d y = %d z = %d\n", x, y ,z);

}

=============================================================

programın sonlandırılması

<stdlib.h>

-exit
-atexit
-abort

!! main'deki return statement ile exit fonkisyonunu çağırmak arasında fark yoktur. derleyici return statementi exit fonksiyonuna dönüştürür

---------------

!! fonskyionların içini boş bırakmak yerine void kullanmak gerekir.

------------

!! main.c içine return 0 konulmasa bile c99 standartı ile return 0 eklenir

atexit : programın sonlanması sırasında özel işlevlerin çağrılmasını sağlar.

int atexit(void (*)void); //geri dönüş değeri olmayan adresi olmayan bir fonksiyon istiyor

void baz(void)
{
printf("bar basliyor\n");
}

void bar(void)
{
printf("bar basliyor\n");
}

void foo(void)
{
printf("foo basliyor\n");
}

void func(void)
{
printf("func cagrildi\n");
exit(EXIT_FAILURE);
}

int main(void)
{
atexit(&baz); //exit çağrıldığında bu fonksyonları çağırsın
//
atexit(&bar);
//
atexit(&foo);

func(); //bunu silsek bile implict olarak derleyici buraya return 0 koyar return 0' da exit fonksyionunu çağırır
}

!! son kayıt edilen ilk çağrılacak, atexit kayıt ettiği için bu şekilde çalışır

-----------------

abort : programı direk sonlandırır

---------

// yazılımda sadece çalışacak kodlar kullanılmaz, bazı seneryoları test edicek fonksiyonlarda yazılması gerekir
// bunun için abort() kullanabiliriz, aşağıdaki gibi

void func(const char * ptr)
{
if (ptr == NULL){
abort(); //fonksiyonu direkt sonlandırmamız gerekir
}
}

int main(void)
{
char str[100] = "bugrahan serttas";

func(strchr(str, 'A'));
}

-------------------

!! assert'de kullanılabilir, her yerde kullanılabilir

void func(const char * ptr)
{
if (ptr == NULL){
assert(ptr != NULL); // programı yine abort sonlandırırı
}
}

int main(void)
{
char str[100] = "bugrahan serttas";

func(strchr(str, 'y'));
}


===================================================

dinamik bellek yönetimi :
--------------------------

dinamik bellek bloğu ne zaman kullanılır : 

- kaç byte bellek alanına ihtiyaç olduğu programın çallışma zamanında belli olur
- bir nesnenin hayatı programın çalışma zamanında t1'de başlayıp t2'ye kadar devam edecek ise ve bu aynı fonk. içinde olmka zorunda değil ise 
- canımız ne zmana isterse bellekten yer edinililmeli

malloc : bellek bloğunu direkt bize verir
calloc : bellek bloğunu sıfırlayarak bize verir 
realloc: daha önce elde edilen bellek boyutunu arttırmak veya azaltmak için kullanılır
free : daha önce ayrılan bellek bloğunu sisteme geri veriyor

--------------------

malloc: bellek havuzunda yer varsa verir yer yoksa veremez, başarısız olursa null pointer verir

---------------

--------------

malloc kullanımına bir senaryo :

mesela dianamik bir dizi return etmek gereiyor bununiçin önce malloc ile 8 byte yer allocate ettik (int* foo = malloc(2* sizeof(int)))
sonrasında foo[0] == *(foo + 0) anlamına geldiği için foo[0]'a değer atayabiliriz sanki vektörde ilk elemana değer atıyoruz gibi, bu durumda foo[1[ bellekte bir diğer adresi gösterir bu da ör: 0x1000	(foo[0]) - 0x1004 (foo[1]
en sonda da bu diziyi return ile döndürebilriiz ==> return foo

------------

neden malloc kullanırızı açıklayan güzel bir yazı :

One example should clear this. Say you know there will be maximum 20 students. So you can create an array with static 20 elements. 
Your array will be able to hold maximum 20 students. But what if you don't know the number of students? 
Say the first input is the number of students. It could be 10, 20, 50 or whatever else. 
Now you will take input n = the number of students at run time and allocate that much memory dynamically using malloc.

#include <stdio.h>

int main(int argc, const char *argv[]) {

    typedef struct {
        char *name;
        char *sex;
        char *insurance;
        int age;
        int yearInSchool;
        float tuitionDue;
    } student;

    // Now I can do two things
    student p;

    // Or
    student *p = malloc(sizeof *p);
}

--------------

void * malloc(size_t n);



int main(void)
{
size_t n;

printf("tam sayi girin: ");
scanf("%zu", &n);
int * pd = (int *)malloc(n * sizeof(int)); //void türünden int türüne dönüşüm
if (pd == NULL){
fprintf(stderr, "cannot allocate memory\n");
return 1;
}

set_array_random(pd ,n);
print_array(pd, n);
free(pd); //free //deallocate

}


-------------

- malloc bize o değeri bir değerle set etmeden olduğu gibi veriyor
- malloc tek parça verir, dizi konumlanıdırılabilir
- o bellek bloğuna heap alanına verene kadar o bellek bloğunu kullanabiliriz
- bellek alanını geri vermez isek o bellek alanını başka bir amaç için kullanılamıyor (memmory leak(age))

-------------


!! malloc çağrısı ile daha önce edinilmiş 
dinamik bir bellek bloğunun büyütülmesi söz konusu değildir. bunu realloc le ancak yapabilriiz

==================

wrapper : fonksiyonu başka bir fonksiyona çağırtmak

neden kullanırız :

1. augmentation : koda ilave kod ekleme

2. argüman kontroli : orn, pointer parametre null pointer mı

3. ortak kodu tek bir yere toplama 

4. parametre sayısını azaltma : fonksiyonlarda fazla parametre yapısı iyi bir şey değildir

5. parametlerin sırası  

6. customize etme

==================


---------------

free : tekrardan bellek bloğunun kullanılmasını sağlar, tekrar o bellek bloğu kullanılabilinir
void free(void * vp);

free işleviyle ilgili tipik hatalar 
------------------------------------

1. dinamik olmayan yani malloc calloc realoc ile edinilmemiş
bellek bloğu adreslerini free işlevine göndermel

int main(void)
{
char str[100];
char * p = str;
free(p); //hata , p dinamik veri adresi değilse hata olur
}

---------------

2. free fonksiyonuna çağrı yaptıktan sonra free edilmiş bellek bloğunun
adresi geçersiz bir adrestir. dangling pointer
!! dangling pointer hiçbir şekilde kullanılmamalı

int main(void)
{
size_t n;

printf("tam sayi girin: ");
scanf("%zu", &n);
int * pd = (int *)malloc(n * sizeof(int)); //void türünden int türüne dönüşüm
if (pd == NULL){
fprintf(stderr, "cannot allocate memory\n");
return 1;
}

set_array_random(pd ,n);
print_array(pd, n);
free(pd); 
pd = NULL; //DİKKAT ÇEKMEK İÇİN YAPILABİLİNİR

!! pd değerini asla kullanma, yeni bir değer atayarak, geçerli bir adres vererek kullanabilirsin
!! eski adresi ile kulanmak dangling pointer
}

------------------

3. free işlevi allocate edilmiş bellek bloğunun adresini istiyor
edinilmiş bir bellek bloğunun bir kısmını geri vermek için işlem yapılamaz

free(pd + n / 2); //sadece malloc, calloc, realloc ile edinilmiş bellek bloğu verilir

!! bir bellek bloğunu birden fazla veri tutabilir, bellek bloğu free edilince dangling pointer olur veriler

4. double free

int* px = pd;
free(px);

-----------

5. memmory leak :allocate edilmiş bellek bloğunun geri verilmemesine denir

-----------

!! return'den önce free yap UNUTMA 

---------

char * mystrdup(const char * p) //malloc çağırdığını dökümante et, free edilmesi gerektiğini yaz
{
char * pd = (char*)malloc(strlen(p) + 1);
if (!pd) return NULL;
strcpy(pd, p);
return pd //return strcpy(pd, p) aynı anlama gelir
}

int main(void)
{
char str[1000];

printf("bir yazi girin: ");
sgets(str);
//yukarıdaki yazı bana ait değil ancak o yazının tersine ihtiyacım var

char * p = mystrdup(str);
_strrev(p);

printf("[%s] [%s]\n", str, p);
free(p);
}


------------

!! c'de yapılan en büyük hata adres döndüren fonksiyonun dökümantasyonuna bak free edilmesi gerekiyor olabilir

-----------

//statik ömürlü nesne adresi döndürsün
//her defasında aynı parola döner çünkü aynı adrese yazar statil ömürlü olduğu için

char * get_random_psw(void);
{
static char str[40];
int len = rand() % 8 + 5;
int i = 0;
for (; i < len; ++i){
str[i] = (rand() % 2 ? 'a' : 'a') + (rand() % 26);
}
str[i] = '\0';
return str;
}

int main(void)
{
char * p[SIZE];
randomize();

for (int i = 0; i < SIZE; ++i){
p[i] = get_random_psw(); //buradan sonra puts(p) ile ekrana bassaydık bu problem çzülürdü (farklı passwordler yazardı)
}
 
for (int i = 0; i < SIZE; ++i){
printf("%s\n", p[i]);
}
}

----------------

//dinamik ömürlü nesne adresi döndürsün

char * get_random_psw(void);
{
int len = rand() % 6 % 5;
char * pd = malloc(len + 1);
if (!pd) return NULL;

for (int i = 0; i < len; i ++){
pd[i] = (rand() % 2 ? 'a' : 'a') + (rand() % 26);
}
pd[len] = '\0';
return pd;
}

int main(void)
{
char * p;
randomize();

for (int i = 0; i < SIZE; ++i){
p[i] = get_random_psw();
puts(p[i]);
free(p);
}
}
return 0;
}


-------------


!! free fonksiyonuna gönderilen argümanını NULL pointer olması 
bir tanımsız davranış değildir. bu durum no-operation(faydasıda yok zararıda)


-------------

!! malloc işlevini dinamik bir pointer dizisi oluşturmak amaçlı da kullanabiliriz

int main(void)
{
int n;

int ** pd = (int**)malloc(n * sizeof(int*)); 
for (int i = 0; i < n; ++i){
pd[i]
}
}


-------------------------------

void * realloc(void * vp, size_t new_size)

1. paramtereye malloc veya calloctan alınmış paramtre alınır
2. paramtereye yeni boyut geçilir 

!! realloc sadece dinamik olarak ayrılmış alanlar üzerinde büyütme veya küçültme yapabilir

int main(void){
size_t n;

printf("kac elemanli dizi istiyorsunuz: ");
scanf("%zu", n);
int * pd = (int*)malloc(n * sizeof(int));
if (!pd){
fprintf(stderr,"bellek yetersiz\n");
return 1;
}
randomize();
set_array_random(pd,n);
printf_array(pd, n);

printf("kac eleman daha ekleyelim: ");
size_t n_plus;
scanf("%zu", n);
pd = (int *)realloc(pd, (n + n_plus * sizeof(int));
if (!pd){
fprintf(stderr, "bellek yetersiz\n");
return 1;
}
set_array_random(pd + n, n_plus);
print_array(pd, n + n_plus);
}


----------------

!! reallocation takes time //zırt pırt çağırma :)
!! reallocation invalidates pointer (eski bellek bloğunu kullanan pointerlar rellacation eski bellek bloğunu free ettiği için dangling pointera sebep olur)

===========================================================

dinamik dizi (dynamic array) veri yapısının (data structure) :

!! cpp'da karşılığı vektörlerdir.

!! üretimde en çok kullanılan yapıdır, DİKKATLİ ÇALIŞ

- continious'dur.
- dinamik olarak veri miktarı değişebilir.

avantajları : 
1- n tane öğeden birine erişme maaliyeti constant time (dizilerde olduğu gibi)
2- sondan eklemeli maaliyeti constant time  (baştan veya ortadan constant time olmaz)

The size of a dynamic array
The capacity of a dynamic array

!! kapasite size'dan büyük tutulur. 
eğer size değeri sürekli artıyor ve kapasiteye eşit olursa diğer arttırma işleminde realloc devereye girer ve kapasiteyi arttırır 
bu sayede size kapasiteyi geçmemiş olur. bu karmaşıklığa 'amortised constant time' denir

amortised constant time  : realloc'un maaliyetinnin görmezden gelinmesine denir

------------------------

int main(void)
{
time_t timer = time(NULL);

const char* p1 = ctime(&timer);
(void)(gets);
const char* p2 = ctime(&timer);
(void)(gets);
const char* p3 = ctime(&timer);
(void)(gets);

puts(p1); //hep aynı adres yazar static adres döndürmediği için, tekrar tekrar bellekte oluşşturulacak
puts(p2);
puts(p3);
}

------------

char * get_psw(void)
{
static char buffer[100]; //static yerel değişken sayesinde tekrar tekrar oluşturulmaz üstüne yazar

int len = rand() % 7 + 5;

for (int i = 0; i < len; ++i){
buffer[i] = rand() & 26 + 'A';
}
buffer[len] = '\0';
return buffer;
}

int main(void)
{
char * p[10];

randomize();
for (int i = 0; i < 10; ++i){
p[i] = ge_psw()
}
}


---------------



void func(void)
{
int call_count = 0; //burası static olmalı

printf("beni %d. kex cagirdilar\n", ++call_count);
}

int main(void)
{
for (int i = 0; i < 10; ++i)
{
func(); //sürekli aynı sayı yazar çünkü her seferinde tekrar hayat gelecektir 
}
}


--------------

!! otomatik ömürlü değişkenler her çağrıldığında stack'de tekrar oluşturulur

int get_xyx_value(int n)
{
static const int primes[] ={ //böyle bir diziyi static yap otomatik olması maaliyetli
2,3,54,21,2,4,12,4,4,3
1,4,2,5,21,2,4,12,21,2,
2,3,54,21,2,4,12,4,4,3
1,4,2,5,21,2,4,12,21,2,
};

return primes[n];
}

================================

linkage kavramı : farklı dosyalarda fonksiyon veya değişken kullanıldığında onun
aynı varlığa mı ilişkin yoksa farklı varlığa mı ilişkin olduğunu söyler

- external linkage (dış bağlantı) : başka modüller tarafından da kullanılabilinir, linker aynı varlık olarak görür
- internal linkage (iç bağlantı) : sadece bu modül kullanabilir, linker farklı varlık olarak görür
- no linkage (bağlantısız) 





         hasan.c                    omer.c    
      |          |               |         |
      |     x    |               |    x    |
      |          |               |         |
      |          |               |         | 
      |          |               |         |         
                                    

external linkage olursa hasan.c dosyası içindeki x değişkenini omer.c kullanabilir
internal linkage olursa hasan.c dosyası içindekli x değişkenini omer.c kullanamz

!! fonksiyonlar için ve global değişkenler varsa default external olur

!! dış bağlantıya açılmış aynı isimde 2 varlık açılamaz 
!! global olarak tanımlamak onları dış bağlantıya sokar
!! extern anahtar sözcüğünün fonksiyon isminde olması veya olmaması arasında fark yok
!! değişkenin external yazılması ile yazılmaması arasında fark vardır

!!!! eğer dışarı açılacak ise kaynak dosyada tanımı yapılır, başlık dosyasında extern bildirimi yapılır.
!!!! static double dval = 2.3 //aynı dosya içinde farklı fonksiyonlarda kullanılabilinir
!!!! int g = 10 (extern yapılmış başlık dosyasında) farklı dosyalarda kullanılabilinir

global değişkenini dışa açmak istiyor musun ?
- evet

//bugra.c
int ival = 1
//bugra.h
extern int gval;

fonksiyonu dışa açmak istiyor musun ?
- evet

//bugra.c
int foo(int x)
{
return x * x;
}

//bugra.h
extern int foo(int x);
int foo(int x); //default extern gelir

global değişkenini dışa açmak istiyor musun ?
hayır
//bugra.c
static int ival = 1

fonksiyonu dışa açmak istiyor musun ?
hayır
//bugra.c
static int bar(int x)
{

}

--------------

!! fonskyinu dışarı açmak istersek

----------------

omer.c

int g = 10;
static double dvaL = 2.3;

void ofunc(void)
{

}

!! g değişkeni dışarı açılabilir
!! dval sadece o kaynak dosyayı ilgilendirir, dışarı açılamaz

-----------------

global alanda static kullanılmasının bambaşka bir anlamı vardır, dış bağlantıya açılamaz demektir,

static int g = 10; //bu değişken sadece bu dosyada aktif olacak


-----------------

const int * func(void); //salt erişim amaçlı kullanılır o nesneyi değiştiremeyiz

-----------------

typedef int* IPTR;

int main(void)
{
int x = 10;
const IPTR p = &x;
//const int * p = &x; //yukarıdaki bildirim bu anlama gelmiyor
int * const p = &x; //bu anlama geliyor
}

===========================================================

user-defined types 

user-defined type oluşturmaya yönelik 3 tane araç seti var:
1-struct (structures) (yapı)
2-union (unions) (birlikler)
3-enum (enuma) (numaralandırma) : hem user-defined type hem integer type


struct
=========

Matrix'e structure tag (yapı etiketi) denir. olmasada legaldir genelde koyarız
struct Matrix {
//member (eleman)
int x;
int x,y,z; //bu şekilde kullanılabilinir

//bu yapıları alabilir
int x,y;
double dval;
int * p;
char str[100];

//sınıfların elemanları fonksiyon olamaz c++ da olabilir
void func();

};




