////////////////////////////////////////////////////1. Ders////////////////////////////////////////////////////

functions pointers devam...

fonksiyon çağırtma 

standart qsort fonskiyonu : functions pointer parametreli fonksiyon
--------------------------

<stdlib.h>

void qsort(void *vpa, size_t size, size_t sz, int (*fp)(const void *, const void*));

dizinin adresi - sıralanıcak dizinin boyutu - dizinin 1 elemanının boyutu

int mycmp(const void* vp1, const void* vp2)
{
  int x = *(const int*)vp1;
  int y = *(const int*)vp2;
  
  int resılt = x % 2 != 0 && y % 2 == 0 || (x % 2 == y % 2) && x > y 

}
int mycmp(const void*, const void*);
{
if (*(const int*)vp1) > (*(const int*)vp2){
return 1;
}

if (*(const int*)vp1) <  (*(const int*)vp2){
return -1;
}
return 0;
}

int main(void)
{
int a[SIZE];
qsort(a, SIZE, sizeof(int),mycmp);

}

!! qsort fonksiyonu sizin adresini gönderdiğiniz fonksiyonu 
sizin adresini gönderdiğiniz dizinin elemanlarının adresleriyle çağırır


--------------------------------------------
!! p + k * sz: dizinin k indisli elemanının adresi


generic bir bubble sort fonksiyonu

qsort ile aynı parametrik yapıda ismi 
gbsort olan bir fonksiyon tanımlayınız tanımladığınız fonksiyonu farklı türden diziler ile
ve farklı karşılaştırma kriterleri ile test ediniz

void g_bubble_sort(void * vpa, size_t size, size_t sz, int (*fp)(const void *, const void *))
{
char * p = (char *)vpa;
for (size_t i = 0; i < size - 1; ++i){
for (size_t k = 0; k < size - 1 - i; ++k){
if (fp(p + k * sz, p + (k + 1) * sz) > 0){
gswap(p + k * sz, p + (k + 1) * sz, sz);
}
// fp nin gösterdiği fonksiyonu dizinin k ve k + 1 indisli elemanlarının adresleriyle çağır
// eger fonksiyon pozitif deger döndürürse dizinin k ve k + 1 indisli elemanlarını takas et
}
}
}

int main(void)
{
int a[SIZE];

randomize();
set_array_random(a, SIZE, sizeof(int), mycmp);
print_array(a, SIZE);
}

--------------

int dcmp(const void* vp1, const void* vp2)
{
double x = *(const double*)vp1;
double y = *(const double*)vp2;

return x > y ? 1 :
x < y ? -1 : 0;
}

int  main(void)
{
double ar[] = {34,56,7,8,90,9.8,7656,4,55,678,9,88,77,34,65,7}
g_bubble_sort(ar, asize(ar), sizeof * ar, dcmp);

for (size_t i = 0; i < asize(ar), sizeof * ar, dcmp);
printf("%f\n", ar[i]);
}

--------------------------------

bsearch : sıralanmış bir dizide arama yapar
--------

void *bsearch(const void *vpkey, const void *vpa, size_t size, size_t sz, int (*)(const void *, const void *))

int main(void)
{
int ar[SIZE];

randomize();
set_array_random(ar, SIZE);

g_bubble_sort(ar, SIZE, sizeof(int), cmp_int);
print_array(ar, SIZE);

int ival;
printf("aranacak deger: ");
(void)scanf("%d", &ival);
int * p = (int *)bsearch(&ival, ar, SIZE, sizeof, cmp_int)

if (p){
printf("bulundu dizinin %d indisli elemani\n", p - ar);
}
else{
printf("bulunamadi\n");
}
}


==================================================

function pointer arrays :

haftanın ayrı günlerinde farklı görevler var ise bunu şu şekilde yaparız (jump table) :
- anahtarı indekse dönüştür indekste bir fonksiyon adresi elde et. o adresteki fonksiyonu çağır.

haftanın farklı günlerinde yapılacak işleri farklı fonksiyolar olarak tanımlarız. bir pointer dizisinde bunların adreslerini tutarız
ve bu fonksiyona bir index gönderip o indeksi dizi elemanı olan fonksiyon pointerının gösterdiği fonksiyonu çağırırız

------

int f1(int);
int f2(int);
int f3(int);
int f4(int);
int f5(int);

int main(void)
{
int (*fptr(int)) = &f1;

int (*fa[5])(int); //bu şekilde gösterilir
int (*fa[5])(int) = {f1, f2, f3,f4,f5}
int (*fa[])(int) = {&f1, &f2, &f3,&f4,&f5} //anlam farklılığı olmaz
asize(fa) // 5

int (*fp)(int);
int (**fptr)(int) = &fp; //dizinin ilk elemanın adresi, fp'nin adresini fonksiyon pointerda tutulması
*fptr = fp //elde ederiz

int (*fa[](int) = {f1, f2, f3, f4, f5};
int (**fptr)(int) = fa; //dizinin ilk elemanının adresi
int (**fptr)(int) = &fa[0] //aynı anlama gelir

}

------

typedef int (*FPTR)(int); //kolay yol

int main(void)
{
FPTR fa[] = {f1,f2,f3,f4,f5};
FPTR * p = fa;
}

-------------------------------

void f1(int x)
{
printf("f1 cagrildi %d\n", x);

}

void f2(int x)
{
printf("f2 cagrildi %d\n", x);

}

void f3(int x)
{
printf("f3 cagrildi %d\n", x);

}

void f4(int x)
{
printf("f4 cagrildi %d\n", x);

}

void f5(int x)
{
printf("f5 cagrildi %d\n", x);

}

typedef void (*FUNCPTR)(int);

int main(void)
{
FUNCPTR fa[] = {&f1,&f2,&f3,&f4,&f5};
for (size_t i = 0; i < asize(fa); ++i){
fa[i](i); //sırayla fonksiyonları yazdırır
}
}


-----------------

void func(int dayno)
{
void (*fpa[7])(void);
//
fpa[dayno]();
}

------------------

standart karakter test fonksiyonlarının isimleriyle (standart giriş akımından alınıcak) 
çağrılabileceği bir kod yapısı oluşturun


typedef int (*FPTEST)(int);

const FPTEST fa[] = {isupper, islower, isalpha, isdigit, isalnum, isxdigit, ispunct, isspace, isblank, isprint, isgraph,iscntrl}; //buradaki const dizinin elemanlarının değeri değişmiycek anlamında kullanılır
const char * const func_names[] = {"isupper", "islower", "isalpha", "isdigit", "isalnum", "isxdigit", "ispunct", "isspace", "isblank", "isprint", "isgraph","iscntrl"};

int main(void)
{
char fname_input(SIZE];
int ch;

printf("karakteri girin: ");
ch = getchar
printf("hangi test fonksiyonu çağrılsn: ");
(void)scanf("%s", fname_input); 

//aşağıddaki kod ayrı bir fonksiyon yapılmalı

size_t i;
for (i = 0; i z asize(func_name) && strcmp(func_names[i], fname_input); ++i)
;

if (i == asize(func_names)){
printf("kusura bakmayın %s isimli bir std. test fonksiyonu yok",fname_input);
return 0;
}
if(fa[i](ch)){
printf("%c karakteri icin %s testi ok\n", ch ,fname_input);
}else{
printf("%c karakteri icin %s testi not ok\n", ch ,fname_input);
}
}

!! mantıksal ilişki içindeki fonksiyonlarla ilgili işlemler yapmak isteniyorsa mantıksal ilişki
içindeki fonksiyonları adreslerini function array'de tutulmalı



--------------------------------------

//func'ın default davranışı foo çağırmak

--
bugra.h

typedef void (*FPTR)(void);
//func'ın default davranışı foo işlevini cagirmak

void func(void);
FPTR set_func(FPTR); //default davranışı değiştirmek için kullanılır
--

--
bugra.c

void bar(void)
int main(void)
{
func(); //foo işlevi çağrılıcak
set_func(&bar);
func(); //func default olarak foo çağırırırdı artık bar fonksiyonunu çağırıcak
set_func(f);
func(); //foo işlevi cagirilicak
}
--

--------------------

--
bugra.c

void foo(void);

FPTR *gfptr = &foo;

void func(void)
{
gfptr();
}

FPTR set_func(FPTR f)
{
FPTR fptemp = gfptr
gfptr = f;
return fptemp;
}

void foo(void)
{
printf("foo cagrildi\n");
}
--

--
bugra.h

void func(void);
FPTR set_func(FPTR);
--
main.c

void bar(void)
{
printf("bar cagrildi\n");
}

int main(void)
{
func();
FPTR f = set_func(&bar);
func();
set_func(f);
func();
}

-------------------------------------

bugra.h

typedef void (*FPTR)(void);
//func çağrıldığında daha önce f_record işleviyle kayıda alınmış fonksiyonlar
//a) kayıt sırasıyla aynı sırada
//b) kayıt sırasıyla ters sırada 
//cagiricak

void func(void);
void f_record(FPTR);

main.c

void f1(void)
{
printf("f1 called\n");
}

void f2(void)
{
printf("f2 called\n");
}

void f3(void)
{
printf("f3 called\n");
}

void f4(void)
{
printf("f4 called\n");
}

int main(void)
{
f_record(f2);
f_record(f4);
f_record(f3);
f_record(f1);

func();
}

bugra.c

static FPTR gfa[]
static int g_idx = 0;

void func(void)
{
for (int i = 0; i < g_idx; ++i){
g_fa[i]();
}
}

void f_record(FPTR f)
{
if (g_idx == AR_SIZE)
return;
g_fa[g_idx] = f;
}

=================================================================

multi-dimesional arrays (çok boyutlu diziler) :

!! çok boyutlu diziler elemanları dizi olan dizilerdir
!! dizinin elemanı bir dizidir

typedef int ar20[20];

int main(void)
{
//int a[10][20];
ar20 a[10];
}

int main(void)
{
int a[10][20];

printf("sizof(a) = %zu\n", sizeof(a)); //10* 20 *4
printf("sizof(a[0]) = %zu\n", sizeof(a)); //20 *4
printf("sizof(a[0][0]) = %zu\n", sizeof(a)); //4
}

---------

int main(void)
{
int a[10][4];

for (int i = 0; i < 10; ++i){
printf("%p %p\n", a + i, &a[i]); //aynı anlama gelir
}
}

------------

int main(void)
{
int a[10][20];
//matrisin 200 tane tam sayısından her biri
a dizisinin elemanlarının elemanları 
}

-----------

tür uyuşmazlığı kontorlü

int main(void)
{
int a[10][20];
int *p = a //error
int * p1 = &a[0][0] //legal
int * p2 = a[0]; //legal, array decay a[10] a ile gösterilebilinir

//p a dizisinin ilk elemanının ilk elemanını göstermesinin yolları
int * p;
p = &a[0][0];
p = a[0]; //array decay
p = (int *)a;
}


-----------
//değer verme

int main(void)
{
int a[5][3] = {
{1,1,1},
{2,2,2}
{3,3,3}
{4,4,4}
}; 

---------------
//sıralama

for (int i = 0; i < 5 i++){
for (int k = 0; i < 3 k++){
printf("%d", a[i][k];
}
printf("\n");
}

--------------
bu şekilde ilk değer verilebinir 

int main(void)
{
int a[100] = {
[3] = 7,
[12] = 8,
[4] = 77,
[68] = 98,
};

}

----------

int main(void)
{
int a[5][6] = {
[2] = {1,1,1,1,1,1),
[1] = {[3] = 7, [1] = 9, [0] = 6},
[3] = {[4] = 8}
};

------------

////////////////////////////////////////////////////////2. Ders/////////////////////////////////////////////////////


int main(void){
double a[10][32];
//a[0] --> double[32]
double * p = a[0] //array decay

int *  ptr = a //hata olur, tür uyuşmazlığı. &a[0]
double (*p)[32] = a; //bu şekilde gösterilir

for (int i = 0; i < 10; ++i){
printf("%p %p %p\n", &a[0], a + i, p++); //hepsi aynı adresi verir
}
}

----------------------------------------

int main(void)
{
int a[4][3] = {
{1,1,1},
{2,1,12},
{5,6,4},
{0,4,3},
}

int(*p)[3] = a;

for (int i = 0; i < 4; ++i){

print_array(a[i],3); // dizinin elemanlarını yazar
print_array(&a[i][0],3); // dizinin elemanlarını yazar
print_array(*p, 3); //dizinin elemanlarını yazdırır
print_array(*p++, 3); //dizinin elemanlarını yazdırır
print_array(*p++, 3); //dizinin elemanlarını yazdırır
print_array(&(*p)[0], 3); ++p; //dizinin elemanlarını yazdırır

}
}

--------------

int main(void)
{
int a[4][3] = {
{1,1,1},
{2,1,12},
{5,6,4},
{0,4,3},
}

for (int i = 0; i < 4; ++i){ // i < asize(a)
for (int k = 0; k < 3; ++k){ // k < asize(a[0])
printf("%d", a[i][k]);
}
printf("\n");
}

------------

int main(void)
{
int a[][] = {1,5,7,2,3,6,1,4,7,8,3,5,2}; //error, 2. parantez dolu olmalı
int a[][4] = {1,5,7,2,3,6,1,4,7,8,3,5,2}; //legal
int a[4][] = {1,5,7,2,3,6,1,4,7,8,3,5,2}; //error 2. paratez dolu olmalı

}


------------

int main(void)
{
int grades[20][12][30];

}

------------

int main(void)
{
int* a[5][10];
int* b[10];
}

------------

int a[10];
int (*foo())[10]
{
return &a; //int (*)[10]
}

int main(void)
{

}

----------
//tür eş ismi ile yazma

int a[10];
typedef int inta10[10];
inta10 * foo()
{
return &a; //int (*)[10]
}

int main(void)
{

}

-----------

int a[10];

typedef int(*myptr)[10];

myptr foo()
{
return &a;
}

int main(void)
{

}

--------

!!! burası önemli

int main(void)
{

int a[10];
int * p = a; 
*p //a dizinin ilk elemanına erişir

int (*ptr)[10] = &a
*ptr //a dizisinin kendisine erişilir

int * p = *ptr;
*p //dizinin ilk elemanın adresine dönüşür 
}


-----------

int main(void)
{
int a[4][5] = {
{1,1,1,1,1},
{2,3,4,6,9},
{4,9,6,2,4},
{7,9,6,1,8},
};

//soru a dizisinin ilk elemanı olan  ilk elemanının adresini bir pointer değişkende tutun  
//3 yolla'da yapılabilir

int * p = &a[0][0];
int * p2 = a[0]; 
int * p3 = (int*)a;

int n = 4 * 5;

while (n--) {
printf("%d ", *p++);

}
}

-------------------
!! çok boyutlu dizi fonksiyona nasıl geçirilir :

void set_ar(int(*p)[5], int size)
{
for (int i = 0; i < size; ++i){
for(int k = 0; k < size; ++k){
p[i][k] = rand() % 10;
}
}

---
void set_ar(int(*p)[5], int size)
{
while(size--){ //bu şekildede yazılabilinir
for (int i = 0; i < 5; ++i)
(*p)[i] = rand() % 10;
++p;
}
}

---
void set_ar(int(*p)[5], int size)
{
for (int i = 0; i < size; ++i){
set_array_random(p[i], 5);
}
}

---
int main(void)
{
int a[4][5];

set_ar(a, 4);
set_ar(&a[0], 4);
}

-----------

fonksiyonun kodunun yazılması :


















