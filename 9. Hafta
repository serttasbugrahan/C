/////////////////////////////////////////////////////1. Ders//////////////////////////////////

#define LOW 100
#define HIGH 500
#define MID ((LOW + HIGH) / 2) //bu şekilde kullanılabilir

!!tamamı büyük harf ile yazılmış ise ön işlemci makrosudur

#define NO_OF_STUDENTS 2340
int main(void)
{
int cnt = NO_OF_STUDENTS
}

sabit isimlendirme yöntemleri
-----------------------------

#define SIZE 100

enum {SIZE = 100};

constant variable

int main(void)
{
const int size = 1000;
}

------------------------

sembolik sabitler veya makrolar 
a)  magic numberin karşılığı olarak kullanılabilir
b) inimatör olarak kullanılmış olabilir


#define hold 1
int main(void)
{
//on
//off
//stand_by
//hold
}

-------------

#define BYTE unsigned char
int main(void)
{
BYTE x = 45;
}

int main(void)
{
int x;
x = 3.14
x = PI //böyle yazmak (macro kullanmak) daha anlaşışı yapar 3.14 pi olduğu bilinmeyebilir
}

!!macrolar : 
-taşınabilirlik sağlar
-sabitleri isimlendirmiş oluruz 
-okunabilirliği arttırır
-kodda değişebilecek değerlerde macrolar kullanılablilir

-------------

#define ANAKOD   main
#define yok   void
#define TAMSAYI   int
#define BAS {
#define SON }

TAMSAYI ANAKOD(yok(
BAS
printf("hello world");
return 0;
SON

===============================================

optimization 
------------

functional-like - functional macro: 
fonksiyon çağrısı gibi görünen ama aslında fonksiyon çağırmayanlara denir


-compiler optimization

-derleyicinin kod zamanında yaptığı optimization

-link time optimization (LTO)

functional macro :
-----------------

#define MAX2() //fonskiyonal macro bu şekilde olmalı pazartez de boşuk olmamlı

#define  MAX2(a, b) a > b ? a : b
int main(void)
{
int x = 45;
int x = 60;

int z = MAX2(x, y); //maaliyeti azalatır
}

---------------
#define square(a)   ((a) * (a)) //bu şekilde kullanılabilir, macro param. parantez içine yazılmalı, dıştakide parantez içine alınmalı
int square(int a)
{
return a * a; 
}

int main(void)
{
int x = 4;
int y;

y = square(x) //bunun yerine macro kullanılabilir
}

-------------

int square(int a)
{
printf("square\n");
return a * a;
}

#define  square(x) ((x) * (x))

int main(void)
{
int i = 46;
int j = (square)(i); //buradamacro devre dışı kalır çünkü macrodan sonra açılan parantez token'ı olmalı
//isim çakışmasını önler
}

statement expression : macro'nun birden fazla kullanılması durumunda güvenlik amacıyla kullanılır, 
({     //içine yazılır   })

////////////////////////////////////////////////////////////////2. DERS////////////////////////////////////

#define asize(x)   (sizeof(x) / sizeof(x[0]))
#define r_elem(x)  (x[rand() % asize(x)]) //macrolar macro içiçnde kullanılabilir

int main(void)
{
int a[] = {2, 5, 6, 5, 6}
relem(a)
}


fonskiyonel macrolar ile fonksiyonların karşılaştırılması :
---------------------------------------------------------

!! macrolar türden bağımsızdır

#define max2(a, b)    ((a) > (b) ? (a) : (b))

fonksiyonel macro dezavantaj :

a) code size : duruma göre artabilir

b) fonksiyonlar kadar debuggerden destek almaz

c) hata riski fazladır fonksiyonlar daha güvenlidir

----------------------------------------

önişlemci operatörleri (preprocessor operators) :

#     stringification / stringizing
##    token-pasting
defined 


#define  nec(a)  #a //çift tırnak almaya yarar
int main(void)
{
printf(nec(ali)) //ali 
}
----
int main(void)
{
printf(
"ali" //derleyici alivelihasanmetin olarak yazar
"veli"
"hasan"
"metin"
}
----
#define iprint(x) printf("%d\n", x)

int main(void)
{
int a = 15;
int b = 15;
int c = 15;
int d = 15;

iprint(a);
iprint(a + b);
iprint(a + b * c - d);
iprint(a + b + b * b + c * c + d * d);

}














