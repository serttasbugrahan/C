//////////////////////////////////////////////////////////////1. Ders////////////////////////////////////////////////////

type qualifiers :
-----------------
const 
volatile
restrict

const :
const correctness

const tekrarı :
-------------
static const int primes[] = { //dizi değişmiycek ve programın sonuna kadar bellekte kalıcak
2,3,4,2,4,,2,3,3,1,,2,13
2,3,3,2,,3,3,2,23,2,21,23
12,,3,34,,6,78,76,6,4,55
};
------------

!!const nesneyi değiştirmek tanımsız davranıştır

void func()
{
const int x = 10;
x = 20;
}

------------
const T* ==> T //bunu kesinlikle yapma (const nesneyi örtülü dönüşüm yapma)
-------------

int * foo(int *);
const int * func(void); //salt erişim amaçlı kullanılır

------------
ziya.h
void func(const int x); //const kullanma

ziya.c
#include "ziya.h"
void func(const int x) //const kullanma
{

}
-----------
typedef int* IPTR;

int main(void)
{
int x = 10;
const IPTR p = &x;
//const int * p = &x; //yukarıdaki bildirim bu anlama gelmiyor
int * const p = &x; //bu anlama geliyor
}
------------------------------

volatile : derleyicinin bu değişkene optimizasyon yapmamasını söyler
derleyici dikkat et x değişkeni program dışı kaynaklar tarafından değiştirilme potansiyelinde
sen bunu bilmessen ben x değişkenini ifadeler içinde kullandığımda optimizasyon

volatile int x = 10;

int main(void)
{
a = x + 5;
b = x * 7;
m = x * x;
}

----------

volatile int flag = 1;

int main(void)
{
while (flag){
///
}
}

-----------

int * volatile ptr = adres; //burada volatile const gibi davranır

-------------------------------
C99
restrict: derleyici daha iyi opt. yapabilsin diye kullanılır

//p1'in gösterdiği nesneyi p1 dışında gösteren yok
//bu iki pointer değişkenin aynı nesneyi gösteriyor olma ihtimali yok
// pointer aliasing  
//eğer derleyici aşağıdaki pointer'ların aynı nesneyi göstermediğini bilirse belirli opt. yapabiliyor

void func(int * restrict p1, int * restrict p2)
{
*p1 = *p2 + 5;
*p1 = *p2 * 3;

}

!!restirct pointerlara aynı nesnenin adreslerini geçmek tanımsız davranıştır

========================================

user-defined types

user-defined type oluşturmaya yönelik 3 tane araç seti var:
1-struct (structures) (yapı)
2-union (unions) (birlikler)
3-enum (enuma) (numaralandırma) : hem user-defined type hem integer type

===============================

structures:
----------

Matrix'e structure tag (yapı etiketi) denir. olmasada legaldir genelde koyarız
struct Matrix {
//member (eleman)
int x;
int x,y,z; //bu şekilde kullanılabilinir

//bu yapıları alabilir
int x,y;
double dval;
int * p;
char str[100];

//sınıfların elemanları fonksiyon olamaz c++ da olabilir
void func();

};

---------
!! struct data türünün x'i ve y'si vardır, struct Data mydata

struct Data {
int x;
};

int main(void)
{
struct Data mydata;

printf("sizeof(struct Data) = %zu\n", sizeof(struct Data));
printf("sizeof(mydata) = %zu\n", sizeof(mydata));
}

----------
yapının operatörlerine 'member selection operators' denir. bu operatörler ile erişilir

. dot operator
-> arrow operator

----------

struct Data{
double dval;
int x, y;
};

int main(void)
{
struct Data mydata;
mydata.dval; //yapı nesnesine erişmek için kullanılır

mydata.x++;
++mydata.x
!mydata.x
}

----------

struct Data {
double dval;
int x, y;
};

struct Data gdata;  //statik ömürlü olduğu için değerleri 0 ile başlayacak
//önceki konularda geçerli olan konular burada da geçerli (global, statik, const)

void func(void)
{
struct Data x; //garbage ile başlar (otomatik olduğu için, diğer kurllar geçerli)
}

---------

struct Data {
double data;
int x, y;
};

int main(void)
{
struct data data; //legal ama karmaşık
data.data = 10; //legal ama karmaşık
}

------

struct Data {
int x,y;
int a
double d;
};

int main(void)
{
struct Data mydata = {10,20,3.4}; //değer verme, içi boş bırakılamaz
struct Data mydata = {0}; //bütün değerler 0 olur.

printf("mydata.x = %d\n", mydata.x);
printf("mydata.y = %d\n", mydata.y);
printf("mydata.d = %d\n", mydata.d);

}

----------

struct Data {
double dval;
int ar[4];
int x;
};

int main(void)
{
struct Data mydata = {
2.3,
{1,3}, //arrray'de parantez kullan
12
};
}
----
struct Data {
double dval;
int ar[4][3];
int x;
};

struct Nec{
int a;
struct Data dx;
};

int main(void)
{
struct Data mydata = {
10, //struct nec'e verilen değer
{{{1,1,1},{2,2,2},{3,3,3}}, //struct data'ya verilen ilk değer
2.3,
}
}

-----------

struct Data {
double dval;
int ar[20];
double dval
int x,y;
};

int main(void)
{
struct Data mydata = {
.dval = 2.3;
.x = 20;
.ar = {[3] = 5, [7] = 9}
};
}
 
---------

struct Nec{
char c1;
int x;
char c2;
}g; //hem struct nec bildirilde hemde ismi g olan global bir değişken bildirildi

struct Nec g; //aynı anlama gelir

--

struct Nec{
char c1;
int x;
char c2;
}g1,g2,g3;

//struct Nec g1,g2,g3; aynı anlama gelir

--

struct Nec{
char c1;
int x;
char c2;
}g1 = {'A', 45, 'B'}; //İLK DEĞER VERİLEBİLİNRİ

--

struct Nec {
int a, b,c;
};

struct Nec g = {12, 4, 67}, * p = &g;

-------
point.h
//struct header dosyasında tanımlanır
struct Point {
int x,y,z;
};

------

struct Point {
double x,y,z;
};

int main(void)
{
struct Point p1 = {2.3, 5.6, 9.2};
struct Point p2 = p1;

}

------

!! bir yapı nesnesini hangi operatörlerin operandı yapabilirim

struct Point {
double x,y,z;
};

int main(void)
{
struct Point p = [2.3, 5.6, 9.2};
//p.x
//sizeof(p);
//&p;
//p = 
}






