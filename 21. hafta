////////////////////////////////////////////////////1. ders//////////////////////////////////////////////////////

//statik ömürlü nesne adresi döndürsün
//her defasında aynı parola döner çünkü aynı adrese yazar statil ömürlü olduğu için

char * get_random_psw(void);
{
static char str[40];
int len = rand() % 8 + 5;
int i = 0;
for (; i < len; ++i){
str[i] = (rand() % 2 ? 'a' : 'a') + (rand() % 26);
}
str[i] = '\0';
return str;
}

int main(void)
{
char * p[SIZE];
randomize();

for (int i = 0; i < SIZE; ++i){
p[i] = get_random_psw();
}

for (int i = 0; i < SIZE; ++i){
printf("%s\n", p[i]);
}
}

----------------

//dinamik ömürlü nesne adresi döndürsün

char * get_random_psw(void);
{
int len = rand() % 6 % 5;
char * pd = malloc(len + 1);
if (!pd) return NULL;

for (int i = 0; i < len; i ++){
pd[i] = (rand() % 2 ? 'a' : 'a') + (rand() % 26);
}
pd[len] = '\0';
return pd;
}

int main(void)
{
char * p;
randomize();

for (int i = 0; i < SIZE; ++i){
p[i] = get_random_psw();
puts(p[i]);
free(p);
}
}
return 0;
}


------------------

int main(void){
int n;

printf("KAC TANE: ");
scanf("%d", &n); // ==> 0)

int  * pd = (int*)malloc(n * sizeof(int));
free(pd);
}

!! free fonksiyonuna gönderilen argümanını NULL pointer olması 
bir tanımsız davranış değildir. bu durum no-operation(faydasıda yok zararıda)

int main(void){
int n;

printf("KAC TANE: ");
scanf("%d", &n); // ==> 0)

//implementation defined

int  * pd = (int*)malloc(n * sizeof(int));
if (pd == NULL)
printf("malloc(0) cagrisi NULL ptr dondurdu\n");
else
printf("malloc(0) cagrisi % p adresini dondurdu\n",pd);

free(pd);
}

------------------------------

!! malloc işlevini dinamik bir pointer dizisi oluşturmak amaçlı da kullanabiliriz

int main(void)
{
int n;

int ** pd = (int**)malloc(n * sizeof(int*)); 
for (int i = 0; i < n; ++i){
pd[i]
}
}

----------
matrisi impremente etmenin 3 yolu:

//satir ve sütun sayısı programın çalışma zamanında belli olan 
bir matris oluşturun ve bu matrisi rastgele değerler ile doldurup
ekrana  yazdırın 

int main(void)
{
size_t row_size, col_size;

printf("olusturulacak matrisin satir ve sutun sayisini giriniz: ");
scanf("%zu%zu", &row_size, &col_size);

int ** pd= (int **)malloc(row_size * sizeof(int*));
if (!pd){
fprintf(stderr,"bellek yetersiz\n");
return 1;
}

for (size_t i = 0; i < row_size; ++i){
pd[i] = (int *)malloc(col_size * sizeof(int));
if (!pd[i]) {
fprintf(stderr, "bellek yetersiz\n");
return 1;
}
}

randomize();

//fill matrix with values
for (size_t i = 0; i < row_size; ++i){
for (size_t k = 0; k < col_size; ++k){
pd[i][k] = rand() % 10;
}

for (size_t i = 0; i < row_size; ++i){
for (size_t k = 0; k < col_size; ++k){
printf("%d", pd[i][k]);
}
printf("\n");
}
}
for (size_t i = 0; i < row_size; ++i){
free(pd[i]; //int dizileri free etmek için
}
free(pd); //pointer diziyi free etmek için
}

//bu şekilde sözde 2 boyutlu dizi oluşturulur, matrisin biri bir yerde diğeri heap alanında bir yerde olur
--------------------------

int main(void){
size_t row_size, col_size;

printf("olusutulucak matrisisn satir ve sutun sayisni giriniz: ");
scanf("%zu%zu", &row_size,&col_size);

int * pd = (int*)malloc(row_size * col_size * sizeof(int));
if (!pd){
fprintf(stderr,"bellek yetersiz\n");
return 1;
}
randomize();

for (size_t i = 0; i < row_size; ++i){
for (size_t k = 0; i < col_size; ++k){
pd[i * col_size + k] = rand() % 10;
}
}

for (size_t i = 0; i < row_size; ++i){
for (size_t k = 0; i < col_size; ++k){
printf("%d",pd[i * col_size + k];
}
printf("\n");
}

// bu kod ile daha az bellek alanı kullandık
// row * col * sizeof(int)
//satırlar bellekte ardışık
//kod tarafında double deref. olamıyor

----------------------

int main(void){
size_t row_size, col_size;

printf("olusutulucak matrisisn satir ve sutun sayisni giriniz: ");
scanf("%zu%zu", &row_size,&col_size);

int * pd = (int*)malloc(row_size * col_size * sizeof(int));
if (!pd){
fprintf(stderr,"bellek yetersiz\n");
return 1;
}
randomize();
int ** ptr = (int**)mallox(row_size * sizeof(int*));

for (size_t i = 0; i < row_size; ++i){
ptr[i] = pd + (i * sizeof(int));
}

for (size_t i = 0; i < row_size; ++i){
for (size_t k = 0; i < col_size; ++k){
ptr[i][k] = rand() % 10;
}
}

for (size_t i = 0; i < row_size; ++i){
for (size_t k = 0; i < col_size; ++k){
printf("%d",ptr[i][k];
}
printf("\n");
}
free(pd);
free(ptr);

-----------------------------------------------------

void * realloc(void * vp, new_size,)

1. paramtereye malloc veya calloctan alınmış paramtre alınır
2. paramtereye yeni boyut geçilir 

!! realloc sadece dinamik olarak ayrılmış alanlar üzerinde büyütme veya küçültme yapabilir

int main(void){
size_t n;

printf("kac elemanli dizi istiyorsunuz: ");
scanf("%zu", n);
int * pd = (int*)malloc(n * sizeof(int));
if (!pd){
fprintf(stderr,"bellek yetersiz\n");
return 1;
}
randomize();
set_array_random();
printf_array(pd, n);

printf("kac eleman daha ekleyelim: ");
size_t n_plus;
scanf("%zu", n);
pd = (int *)realloc(pd, (n + n_plus * sizeof(int));
if (!pd){
fprintf(stderr, "bellek yetersiz\n");
return 1;
}
set_array_random(pd + n, n_plus);
print_array(pd, n + n_plus);
}

-----------------------------

!! reallocation takes time, zırt pırt çağırma :)
!! reallocation invalidates pointer 

realloc(NULL, n) ile malloc(n) arasınd fark yok

int main(void)
{
//döngüsel bir yapı içinde bir dinamik diziyi sürekli 1 eleman büyütmek

for (;;){
printf("tam sayi girecek misiniz: (e) (h)");
while ((ch = _getch()) != 'e' && ch != 'h')
;
printf("%c\n", ch);
if (ch == 'h')
break;
printf("tam sayiyi girin: ");
}
}


//2.33




